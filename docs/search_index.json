[["index.html", "Aerial Imagery and Point Cloud Data for Slash Pile Quantification Section 1 Introduction 1.1 Objective 1.2 Data", " Aerial Imagery and Point Cloud Data for Slash Pile Quantification George Woolsey 21 May, 2025 Section 1 Introduction Code in support of “Aerial Imagery and Point Cloud Data for Slash Pile Quantification” 1.1 Objective The objective of this study is to demonstrate the use of aerial point cloud data (SfM) and both RGB and hyperspectral imagery to identify and quanity slash piles. 1.2 Data "],["data-processing.html", "Section 2 Data Processing 2.1 Slash Pile Vector Data 2.2 Point Cloud Data 2.3 Check out one pile 2.4 Load RGB orthomosaic rasters 2.5 Study area imagery", " Section 2 Data Processing Load the standard libraries we use to do work # bread-and-butter library(tidyverse) # the tidyverse library(viridis) # viridis colors library(harrypotter) # hp colors library(RColorBrewer) # brewer colors library(scales) # work with number and plot scales library(latex2exp) # visualization library(mapview) # interactive html maps library(kableExtra) # tables library(patchwork) # combine plots # spatial analysis library(terra) # raster library(sf) # simple features library(lidR) # lidar data library(rgl) # 3d plots library(cloud2trees) # the cloud2trees 2.1 Slash Pile Vector Data slash_piles_sf &lt;- sf::st_read(&quot;D:\\\\PFDP_Data\\\\PFDP_SlashPiles\\\\SlashPiles.shp&quot;) %&gt;% dplyr::rename_with(tolower) ## Reading layer `SlashPiles&#39; from data source ## `D:\\PFDP_Data\\PFDP_SlashPiles\\SlashPiles.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 122 features and 8 fields ## Geometry type: POINT ## Dimension: XYZM ## Bounding box: xmin: 1019067 ymin: 4334804 xmax: 1019496 ymax: 4335198 ## z_range: zmin: 0 zmax: 2831.171 ## m_range: mmin: 0 mmax: 1566318000 ## Projected CRS: WGS 84 / UTM zone 12N what? slash_piles_sf %&gt;% dplyr::glimpse() ## Rows: 122 ## Columns: 9 ## $ objectid &lt;dbl&gt; 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,… ## $ comment &lt;chr&gt; &quot;Mechanical Pile&quot;, &quot;Mechanical Pile&quot;, &quot;Mechanical Pile&quot;, &quot;Ha… ## $ comment2 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ height &lt;dbl&gt; 21.0, 19.0, 17.0, 6.5, 7.0, 7.5, 7.0, 8.0, 6.5, 7.5, 7.5, 7.… ## $ diameter &lt;dbl&gt; 28.0, 27.0, 24.0, 10.6, 10.0, 10.0, 11.5, 10.5, 11.0, 11.0, … ## $ xcoord &lt;dbl&gt; 1019466, 1019451, 1019449, 1019437, 1019408, 1019397, 101938… ## $ ycoord &lt;dbl&gt; 4335040, 4335004, 4334968, 4334825, 4334828, 4334834, 433484… ## $ refcorner &lt;chr&gt; &quot;Z12&quot;, &quot;Z10&quot;, &quot;Y8&quot;, &quot;X1&quot;, &quot;W1&quot;, &quot;V2&quot;, &quot;V2&quot;, &quot;U1&quot;, &quot;K7&quot;, &quot;T1&quot;… ## $ geometry &lt;POINT [m]&gt; POINT ZM (1019466 4335040 2..., POINT ZM (1019451 4335… where? mapview::mapview(slash_piles_sf, zcol = &quot;comment&quot;, layer.name = &quot;slash piles&quot;) 2.2 Point Cloud Data Let’s check out the point cloud data we got using UAS-SfM methods # directory with the downloaded .las|.laz files f &lt;- &quot;D:\\\\PFDP_Data\\\\p4pro_images\\\\P4Pro_06_17_2021_half_half_optimal\\\\2_densification\\\\point_cloud&quot; # is there data? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;) %&gt;% length() ## [1] 1 # what files are in here? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;)[1] ## [1] &quot;P4Pro_06_17_2021_half_half_optimal_group1_densified_point_cloud.las&quot; what information does lidR read from the catalog? ctg_temp &lt;- lidR::readLAScatalog(f) # set the processing options lidR::opt_progress(ctg_temp) &lt;- F lidR::opt_filter(ctg_temp) &lt;- &quot;-drop_duplicates&quot; lidR::opt_select(ctg_temp) &lt;- &quot;xyziRGB&quot; # huh? ctg_temp ## class : LAScatalog (v1.2 format 3) ## extent : 499264.2, 499958.8, 4317541, 4318147 (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 13N ## area : 420912.1 m² ## points : 158.01 million points ## density : 375.4 points/m² ## num. files : 1 that’s a lot of points…can an ordinary laptop handle it? we’ll find out. We’ll plot our point cloud data tiles real quick to orient ourselves ctg_temp %&gt;% purrr::pluck(&quot;data&quot;) %&gt;% mapview::mapview(popup = F, layer.name = &quot;point cloud tile&quot;) 2.3 Check out one pile las_temp &lt;- lidR::clip_roi( ctg_temp # biggest mechanical , slash_piles_sf %&gt;% dplyr::filter(tolower(comment)==&quot;mechanical pile&quot;) %&gt;% dplyr::arrange(desc(diameter)) %&gt;% dplyr::slice(1) %&gt;% sf::st_zm() %&gt;% sf::st_buffer(10, endCapStyle = &quot;SQUARE&quot;) %&gt;% sf::st_transform(lidR::st_crs(ctg_temp)) ) what did we get? las_temp@data %&gt;% dplyr::glimpse() ## Rows: 181,282 ## Columns: 7 ## $ X &lt;dbl&gt; 499807.0, 499807.0, 499807.0, 499807.0, 499807.0, 499807.0, … ## $ Y &lt;dbl&gt; 4317975, 4317975, 4317975, 4317975, 4317975, 4317975, 431797… ## $ Z &lt;dbl&gt; 2714.829, 2714.777, 2714.709, 2714.900, 2714.636, 2714.594, … ## $ Intensity &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ R &lt;int&gt; 20224, 16896, 32256, 44288, 21760, 16896, 14592, 35584, 3148… ## $ G &lt;int&gt; 18176, 16640, 34304, 40960, 20480, 14848, 8704, 34048, 34304… ## $ B &lt;int&gt; 16384, 16384, 33280, 36608, 20992, 14336, 7168, 33280, 35072… plot a sample las_temp %&gt;% lidR::plot( color = &quot;Z&quot;, bg = &quot;white&quot;, legend = F , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) make a gif library(magick) if(!file.exists(file.path(&quot;../data/&quot;, &quot;pile_z.gif&quot;))){ rgl::close3d() lidR::plot( las_temp, color = &quot;Z&quot;, bg = &quot;white&quot;, legend = F , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = &quot;pile_z&quot;, dir = &quot;../data/&quot;) rgl::close3d() } library(magick) if(!file.exists(file.path(&quot;../data/&quot;, &quot;pile_rgb.gif&quot;))){ rgl::close3d() lidR::plot( las_temp, color = &quot;RGB&quot;, bg = &quot;white&quot;, legend = F ) rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = &quot;pile_rgb&quot;, dir = &quot;../data/&quot;) rgl::close3d() } 2.4 Load RGB orthomosaic rasters Orthomosaic tif files from the UAS flight imagery that were created in Agisoft Metashape are loaded and stitched together via terra::mosaic. # read list of orthos ortho_list_temp &lt;- list.files( &quot;D:\\\\PFDP_Data\\\\p4pro_images\\\\P4Pro_06_17_2021_half_half_optimal\\\\3_dsm_ortho\\\\2_mosaic&quot; , pattern = &quot;*\\\\.(tif|tiff)$&quot;, full.names = T)[] %&gt;% purrr::map(function(x){terra::rast(x)}) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(20) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ####### ensure the resolution of the rasters matches # terra::res(ortho_list_temp[[1]]) ## function change_res_fn &lt;- function(r, my_res=1){ r2 &lt;- r terra::res(r2) &lt;- my_res r2 &lt;- terra::resample(r, r2) return(r2) } ## apply the function ortho_list_temp &lt;- 1:length(ortho_list_temp) %&gt;% purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.25)}) # terra::res(ortho_list_temp[[1]]) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ######## mosaic the raster list ortho_rast &lt;- terra::mosaic( terra::sprc(ortho_list_temp) , fun = &quot;min&quot; # min only thing that works ) # ortho_rast %&gt;% # terra::aggregate(4) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) ortho plot fn ###################################################################################### # function to plot ortho + stand ###################################################################################### ortho_plt_fn = function(stand = las_ctg_dta %&gt;% sf::st_union() %&gt;% sf::st_as_sf(), buffer = 20){ # convert to stars ortho_st &lt;- ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( stand %&gt;% sf::st_buffer(buffer) %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + # geom_sf( # data = stand # , alpha = 0 # , lwd = 1.5 # , color = &quot;gray22&quot; # ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) , legend.key = element_rect(fill = &quot;white&quot;) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 8, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 6, hjust = 0.5, face = &quot;italic&quot;) ) return(plt_combine) } plot an example slash pile RGB image stand_temp = slash_piles_sf %&gt;% dplyr::filter(tolower(comment)==&quot;mechanical pile&quot;) %&gt;% dplyr::arrange(desc(diameter)) %&gt;% dplyr::slice(1) %&gt;% sf::st_zm() %&gt;% sf::st_buffer(10, endCapStyle = &quot;SQUARE&quot;) %&gt;% sf::st_transform(terra::crs(ortho_rast)) # check it with the ortho ortho_plt_fn(stand = stand_temp) ggsave(&quot;../data/pile_rgb.jpeg&quot;, height = 5, width = 5) 2.4.1 Example ratio-based index let’s define a general function for a ratio based (vegetation) index spectral_index_fn &lt;- function(rast, layer1, layer2) { bk &lt;- rast[[layer1]] bi &lt;- rast[[layer2]] vi &lt;- (bk - bi) / (bk + bi) return(vi) } The Green-Red Vegetation Index (GRVI) uses the reflectance of green and red bands to assess vegetation health and identify ground cover types. The formula is GRVI = (green - red) / (green + red). Higher GRVI values indicate healthy vegetation, while negative values suggest soils, and values near zero may indicate water or snow. grvi_rast &lt;- spectral_index_fn(rast = ortho_rast, layer1 = 2, layer2 = 1) terra::plot(grvi_rast) let’s check the GRVI for a pile # check it with the ortho grvi_rast %&gt;% terra::crop(stand_temp %&gt;% sf::st_buffer(20)) %&gt;% terra::as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot2::ggplot() + ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = f), color = NA) + ggplot2::labs(fill=&quot;CHM (m)&quot;) + # harrypotter::scale_fill_hp(&quot;slytherin&quot;) + scale_fill_gradient2(low = &quot;black&quot;, high = &quot;forestgreen&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + ggplot2::theme_void() + theme( legend.position = &quot;none&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) , legend.key = element_rect(fill = &quot;white&quot;) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 8, hjust = 0.5, face = &quot;italic&quot;) ) ggsave(&quot;../data/pile_grvi.jpeg&quot;, height = 5, width = 5) 2.5 Study area imagery let’s look at the RGB imagery and pile locations # get the base plot plt_rgb_ortho &lt;- ortho_plt_fn( slash_piles_sf %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% sf::st_buffer(50) %&gt;% sf::st_transform(terra::crs(ortho_rast)) ) ## |---------|---------|---------|---------|========================================= # add pile locations plt_rgb_ortho + ggplot2::geom_sf( data = slash_piles_sf %&gt;% sf::st_transform(terra::crs(ortho_rast)) , ggplot2::aes() # size = diameter , shape = 1 , color = &quot;firebrick&quot; ) + ggplot2::theme(legend.position = &quot;none&quot;) notice these are point measurements of plot locations and the points are not precisely in the center of the pile. notice also there are piles in the imagery that were not measured (e.g. upper-left corner) let’s make a panel of plots for each pile p_fn_temp &lt;- function(rn, df = slash_piles_sf, buff = 6.5, crs = terra::crs(ortho_rast)) { # scale the buffer based on the largest sc &lt;- buff/max(df$diameter, na.rm = T) d &lt;- df %&gt;% dplyr::arrange(tolower(comment), desc(diameter)) %&gt;% dplyr::slice(rn) %&gt;% sf::st_zm() d &lt;- d %&gt;% sf::st_buffer( dplyr::case_when( is.null(d$diameter) | is.na(d$diameter) ~ buff , d$diameter &lt;= 0 ~ buff , T ~ sc*d$diameter ) , endCapStyle = &quot;ROUND&quot; ) %&gt;% sf::st_transform(crs) # plt ortho_plt_fn(d) + ggplot2::geom_sf(data = d, fill = NA, color = &quot;firebrick&quot;) + ggplot2::labs( subtitle = paste0( tolower(d$comment) , &quot;\\ndiam. = &quot; , scales::comma(d$diameter, accuracy = 0.1) , &quot;, ht. = &quot; , scales::comma(d$height, accuracy = 0.1) ) ) } # add pile locations plt_list_rgb &lt;- 1:nrow(slash_piles_sf) %&gt;% purrr::map(p_fn_temp) plot tiles patchwork::wrap_plots( sample( plt_list_rgb, size = as.integer(nrow(slash_piles_sf)/3)) , ncol = 5 ) ggsave(&quot;../data/pile_tiles_rgb.jpeg&quot;, height = 10.5, width = 8) we have point locations of piles. object-based image analysis will require polygon data so that we have sets of pixels (i.e. “objects”) to work with for training our model. notice that defining the pile “objects” with this point data is going to be challenging given the point locations appear to not have been measured at the center of each pile. if they had, we could use the point location and then buffer by the pile diameter to get the pile extent. another challenge will be training a model with the different lighting conditions in the imagery (e.g. piles in shadows or under tree crowns) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
