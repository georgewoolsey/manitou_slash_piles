# RGB Classification

We'll use the RGB imagery alone to explore unsupervised and supervised classification algorithms.

Ultimately, it is likely we will use an object-based image analysis (OBIA) approach. OBIA is a technique (or a set of techniques) used to analyze digital images that was developed relatively recently in comparison to ‘classic’ pixel-based image approaches ([Burnett and Blaschke 2003](https://doi.org/10.1016/S0304-3800(03)00139-X)). We will probably implement the OBIA approach using the `SegOptim` [package](https://github.com/joaofgoncalves/SegOptim) presented by [Goncalves et al. (2019)](https://doi.org/10.1016/j.jag.2018.11.011)

In future sections we will explore, integration of spectral data with the 3D point cloud data (i.e. "data fusion") to test distinguishing the woody material in slash piles from surrounding vegetation or soil. Field-measured slash piles will be used as the ground truth data to perform a confusion matrix-based validation accuracy assessment of the methods.

[Norton et al. (2022)](https://doi.org/10.3390/rs14122896) combined LiDAR and hyperspectral data in a data fusion approach for classification of semi-arid woody cover species and achieved accuracies ranging from 86% to 98% for five woody species

We'll see how far we can get without hyperspectral data since this data is less common

## Textural covariates

[Rodman et al. (2019)](https://doi.org/10.1002/ecs2.2594) described a method using a series of image processing steps to add supplemental information describing the texture and context surrounding each image pixel in their analysis of forest cover change based only on panchromatic imagery (i.e. "black and white"). These textural covariates may be helpful for identifying slash piles, especially if we only have RGB data.

first, we'll make a single panchromatic band (the mean of red, green, and blue values) from our RGB imagery

```{r}
rgb_to_pan_fn <- function(r, g, b) {
  pan <- (r + g + b)/3
  # replace all 0's with na
  pan <- terra::subst(pan, from = 0, to = NA)
  return(pan)
}
panchromatic_rast <- rgb_to_pan_fn(
  ortho_rast[[1]], ortho_rast[[2]], ortho_rast[[3]]
)
```

quick plot

```{r}
terra::plot(
  panchromatic_rast
  , col = scales::pal_grey(0, 1)(100)
  , axes=F, legend = F
)
```

nice, now we'll make the textural covariates described by [Rodman et al. (2019)](https://doi.org/10.1002/ecs2.2594)

>During these steps, we identified locally dark pixels (indicative of individual trees surrounded by bright grassland) and quantified local standard deviation in brightness using moving windows at multiple scales (sensu Coburn and Roberts 2004; Fig. 3; Appendix S2). We combined these two layers with the original grayscale imagery to create three-band composite imagery (Fig. 3d). The combination of brightness, local minima, and standard deviation emphasizes differences in spectral reflectance that facilitate the separation of different forest structures (e.g., individual trees and dense stands) from non-forested areas. (p. 7)

and from Appendix S2

>Our first metric identifies pixels that are darker than their surroundings (hereafter "local minima"). To identify local minima, we calculated the mean and standard deviation of pixel brightness at each scale (3-15 pixel windows). A pixel was considered to be darker than its surroundings if its brightness value was lower than the window mean minus two standard deviations. These calculations were made for each window size for each pixel, then summed across all window sizes (thus, local minima values range 0-7, where 7 indicates that a pixel is darker than its surroundings across all moving window sizes; Fig. 3b) 

>For the second metric, we calculated the sum of standard deviation values across all window sizes (Fig. 3c). Standard deviation of pixel brightness is a simple version of local texture that can improve forest classification in high-resolution imagery. While standard deviation is more computationally efficient than many other texture metrics (e.g., entropy based on greylevel co-occurrence matrices), it may still yield comparable performance in classification (Coburn and Roberts 2004). Standard deviation appeared helpful in separating dark forest stands (low brightness, moderate variance) from more homogenous areas (low brightness, low variance; i.e., water bodies, shadows). 

>We combined these three layers (brightness, local minima, and standard deviation) to create a three-band composite image (Fig. 3d)


```{r, include=FALSE, eval=TRUE}
round_to_nearest_odd <- function(x) {
  rounded_int <- round(x)

  # Step 2: Check if the rounded integer is already odd.
  is_odd <- (rounded_int %% 2 != 0)

  # Step 3: For numbers that rounded to an even integer, find the nearest odd.
  odd_down <- rounded_int - 1
  odd_up <- rounded_int + 1

  # Calculate the absolute distances from the original number 'x'
  dist_down <- abs(x - odd_down)
  dist_up <- abs(x - odd_up)

  # Step 4: Use ifelse for vectorized conditional logic.
  result <- ifelse(is_odd,
                   rounded_int, # If the initially rounded integer is odd, use it.
                   ifelse(dist_down < dist_up,
                          odd_down, # If 'odd_down' is strictly closer.
                          odd_up    # If 'odd_up' is closer or equidistant.
                   )
  )

  return(result)
}
# round_to_nearest_odd(c(3.5, 4.2, 6.1, 7))
```


```{r}
rast_rodmanetal2019_fn <- function(
    rast, windows_m = c(3,5,7,9,11,13,15), scale_to_1m = T
    , rast_nm = "panchromatic"
) {
  rast <- rast[[1]]
  
  # scale the windows based on resolution
  if(scale_to_1m){
    windows_m <- round_to_nearest_odd(
      (1/terra::res(rast)[1])*windows_m
    )
  }else{
    windows_m <- round_to_nearest_odd(windows_m)
  }
  
  # means
  r_means <- windows_m %>% 
    purrr::map(\(w)
      terra::focal(x = rast, w = w, fun = "mean", na.rm = T)
    )
  # r_means[[7]] %>% terra::plot(col = scales::pal_grey(0, 1)(100))
  
  # sds
  r_sds <- windows_m %>% 
    purrr::map(\(w)
      terra::focal(x = rast, w = w, fun = "sd", na.rm = T)
    )
  # r_sds[[5]] %>% terra::plot(col = scales::pal_grey(0, 1)(100))
  
  # local min
  local_min_fn <- function(rast, mean, sd) {
    as.numeric(rast < ( mean-(sd*2) ))
  }
  
  r_local_min <- 1:length(r_means) %>% 
    purrr::map(\(i)
      local_min_fn(rast = rast, mean = r_means[[i]], sd = r_sds[[i]])
    )
  # r_local_min[[5]] %>% terra::plot()
  
  # aggregate local min
  r_local_min_agg <- terra::rast(r_local_min) %>% 
    cumsum()
  
  # get the last of the local mins
  local_minima <- r_local_min_agg[[terra::nlyr(r_local_min_agg)]]
  
  # aggregate local sd
  r_sds_agg <- terra::rast(r_sds) %>% 
    cumsum()
  
  # get the last of the local mins
  local_sd <- r_sds_agg[[terra::nlyr(r_sds_agg)]]
  
  # composite
  composite <- c(rast, local_sd, local_minima)
  names(composite) <- c(rast_nm, "local_sd", "local_minima")
  
  # names
  names(local_minima) <- c("local_minima")
  names(local_sd) <- c("local_sd")
  
  return(list(
    local_minima = local_minima
    , local_sd = local_sd
    , composite = composite
  ))
}
```

### Raster Texture: Panchromatic

implement our `rast_rodmanetal2019_fn` function
```{r}
rodmanetal2019_panchromatic_rast <- rast_rodmanetal2019_fn(
  rast = panchromatic_rast
  , rast_nm = "panchromatic"
  , scale_to_1m = F
)
```

plot of "local minima" pixels that are darker than their surroundings

```{r}
# plot
terra::plot(
  rodmanetal2019_panchromatic_rast$local_minima
  , col = scales::pal_grey(0, 1)(8)
  , axes=F, legend = F
)
```

plot of standard deviation pixel brightness which is a simple version of local texture that can improve forest classification in high-resolution imagery

```{r}
terra::plot(
  rodmanetal2019_panchromatic_rast$local_sd
  , col = scales::pal_grey(0, 1)(100)
  , axes=F, legend = F
)
```

plot of these combined panchromatic, local minima, and standard deviation images were merged to create a three-band composite which can be segmented to identify areas of relatively homogeneous brightness, contrast, and variance

```{r}
terra::plotRGB(
  rodmanetal2019_panchromatic_rast$composite
  # , scale = c(255,7,520)
  , stretch = "hist", colNA = "transparent"
)
```

### Raster Texture: GRVI

implement our `rast_rodmanetal2019_fn` function
```{r}
rodmanetal2019_grvi_rast <- rast_rodmanetal2019_fn(
  rast = grvi_rast
  , rast_nm = "grvi"
  , scale_to_1m = F
)
```

plot of these combined GRVI

```{r}
terra::plotRGB(
  rodmanetal2019_grvi_rast$composite
  # , scale = c(255,7,520)
  , stretch = "hist", colNA = "transparent"
)
```

### Plot textural rasters

let's look at these textural rasters for some of the piles

```{r}
p_fn_temp <- function(
    rn
    , df = slash_piles_sf
    , composite_rast = rodmanetal2019_grvi_rast$composite
    , buff = 6.5, crs = terra::crs(ortho_rast)
    , my_title = ""
) {
  # scale the buffer based on the largest
    sc_temp <- buff/max(df$diameter, na.rm = T)
    d_temp <- df %>%
      dplyr::arrange(tolower(comment), desc(diameter)) %>% 
      dplyr::slice(rn) %>% 
      sf::st_zm() 
    d_temp <- d_temp  %>% 
      sf::st_buffer(
        dplyr::case_when(
          is.null(d_temp$diameter) | is.na(d_temp$diameter) ~ buff
          , d_temp$diameter <= 0 ~ buff
          , T ~ sc_temp*d_temp$diameter
        )
        , endCapStyle = "ROUND"
      ) %>% 
      sf::st_transform(crs)
    
    # plt classifier
    # convert to stars
    comp_st <- composite_rast %>%  
      terra::subset(subset = c(1,2,3)) %>%
      terra::crop(
        d_temp %>% sf::st_buffer(20) %>% terra::vect()
      ) %>% 
      # terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
      stars::st_as_stars()
    
    # convert to rgb
    comp_rgb <- stars::st_rgb(
      comp_st[,,,1:3]
      , dimension = 3
      , use_alpha = FALSE
      # , stretch = "histogram"
      , probs = c(0.002, 0.998)
      , stretch = "percent"
    )
    # ggplot
    comp_temp <- ggplot2::ggplot() +
      stars::geom_stars(data = comp_rgb[]) +
      ggplot2::scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
      ggplot2::geom_sf(data = d_temp, fill = NA, color = "white", lwd = 0.3) +
      ggplot2::scale_x_continuous(expand = c(0, 0)) +
      ggplot2::scale_y_continuous(expand = c(0, 0)) +
      ggplot2::labs(
        x = ""
        , y = ""
        , subtitle = my_title
      ) +
      ggplot2::theme_void() +
      ggplot2::theme(
        legend.position = "none" # c(0.5,1)
        , legend.direction = "horizontal"
        , legend.margin = margin(0,0,0,0)
        , legend.text = element_text(size = 8)
        , legend.title = element_text(size = 8)
        , legend.key = element_rect(fill = "white")
        # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
        , plot.title = element_text(size = 8, hjust = 0.5, face = "bold")
        , plot.subtitle = element_text(size = 6, hjust = 0.5, face = "italic")
      )
    
  plt_temp <- comp_temp
  return(list("plt"=plt_temp,"d"=d_temp))
}
# combine 3
plt_combine_temp <- function(
    rn
    , df = slash_piles_sf
    , composite_rast1 = rodmanetal2019_panchromatic_rast$composite
    , title1 = "panchromatic composite"
    , composite_rast2 = rodmanetal2019_grvi_rast$composite
    , title2 = "GRVI composite"
    , buff = 6.5, crs = terra::crs(ortho_rast)
) {
  # composite 1
  ans1 <- p_fn_temp(
    rn = rn
    , df = df
    , composite_rast = composite_rast1
    , my_title = title1
    , buff = buff, crs = crs
  )
  # composite 2
  ans2 <- p_fn_temp(
    rn = rn
    , df = df
    , composite_rast = composite_rast2
    , my_title = title2
    , buff = buff, crs = crs
  )
  # plt rgb
    rgb_temp <-
      ortho_plt_fn(ans1$d) + 
      ggplot2::geom_sf(data = ans1$d, fill = NA, color = "white", lwd = 0.3)
  # combine
    r <- ans1$plt + ans2$plt + rgb_temp
    return(r)
}

# add pile locations
plt_list_grvi_comp <- sample(1:nrow(slash_piles_sf),10) %>% 
  purrr::map(plt_combine_temp)
# plt_list_grvi_comp[[2]]
```

combine the plots for a few piles

```{r, height = 10.5, width = 5}
patchwork::wrap_plots(
  plt_list_grvi_comp
  , ncol = 1
)
ggplot2::ggsave("../data/pile_tiles_texture.jpeg", height = 10.5, width = 5)
```

## Unsupervised classification

Unsupervised image classification could be used to identify slash piles by grouping pixels with similar spectral characteristics. We'll call any method that implements classification at the pixel level like the unsupervised classification approach tested here "pixel-based image analysis" versus to OBIA. Unsupervised image classification uses algorithms like K-means to find natural clusters within spectral data and can use other inputs like elevation or spectral indices. This method operates without requiring pre-defined training data, making it useful when field data is limited. The output assigns each pixel to a class, which the user then interprets to potentially identify slash piles based on their distinct spectral signatures and elevated height. While effective for initial classification and pattern recognition, unsupervised methods can produce numerous classes that require manual interpretation and may be less accurate than supervised approaches without ground truth data.

let's test it out and see what we get

first, we'll convert our rasters to a data frame

```{r}
#rename composites
names(rodmanetal2019_panchromatic_rast$composite) <- c(
  "panchromatic", "panchromatic_local_sd", "panchromatic_local_minima"
)
names(rodmanetal2019_grvi_rast$composite) <- c(
  "grvi", "grvi_local_sd", "grvi_local_minima"
)
# combine rasters as data frame
pred_df <- terra::as.data.frame(
    c(
      terra::subset(ortho_rast, c("red","green","blue"))
      , rodmanetal2019_panchromatic_rast$composite
      , rodmanetal2019_grvi_rast$composite
    )
    , xy = T
    , cell = T
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      .cols = c(red,green,blue)
      , .fns = ~ ifelse(.x==0,NA,.x)
    )
  ) %>% 
  # we can't have NA values in kmeans
  dplyr::mutate(
    dplyr::across(
      .cols = dplyr::everything()
      , .fns = ~ as.numeric(ifelse(is.na(.x),-99,.x))
    )
  )
# what is this data?
pred_df %>% dplyr::slice_sample(n=100) %>% dplyr::glimpse()
```

check out correlations between covariates

```{r}
# corrplot::corrplot.mixed(
corrplot::corrplot(
  pred_df %>% dplyr::select(-c(cell,x,y)) %>% stats::cor()
  , method = "ellipse"
  , order = "original" # "alphabet"
  , type = "lower"
  , diag = FALSE
)
```

```{r, include = F, eval = F}
pred_df %>% 
  dplyr::slice_sample(prop = 0.2) +
  ggplot(aes(x = grvi, y = panchromatic_local_minima)) +
  geom_point() + 
  geom_smooth(se=F, method = "lm")
```


perform kmeans clustering

```{r}
set.seed(111)
# Create 6 clusters, allow 500 iterations, start with 5 random sets using "Lloyd"
kmncluster <- stats::kmeans(
  pred_df %>% dplyr::select(-c(cell,x,y))
  , centers=6
  , iter.max = 500
  , nstart = 5
  , algorithm="Lloyd"
)
# kmeans returns an object of class kmeans
str(kmncluster)
```

put the kmeans clusters into a raster

```{r}
# make a blank raster
kmeans_cluster_rast <- terra::rast(ortho_rast, nlyr=1)
# fill the raster
kmeans_cluster_rast[pred_df$cell] <- kmncluster$cluster
# what?
kmeans_cluster_rast
```

there should be at most 6 clusters

```{r}
terra::freq(kmeans_cluster_rast)
```

plot the kmeans unsupervised classfication result

```{r}
terra::plot(
  kmeans_cluster_rast
  , col = viridis::turbo(n=6)
  , axes=F, legend = F
)
```

neat, let's see if the piles are classified by making a custom function to plot the classified raster and RGB side-by-side

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

```{r}
p_fn_temp <- function(
    rn
    , df = slash_piles_sf
    , cluster_rast = kmeans_cluster_rast
    , buff = 6.5, crs = terra::crs(ortho_rast)
) {
  # scale the buffer based on the largest
    sc_temp <- buff/max(df$diameter, na.rm = T)
    d_temp <- df %>%
      dplyr::arrange(tolower(comment), desc(diameter)) %>% 
      dplyr::slice(rn) %>% 
      sf::st_zm() 
    d_temp <- d_temp  %>% 
      sf::st_buffer(
        dplyr::case_when(
          is.null(d_temp$diameter) | is.na(d_temp$diameter) ~ buff
          , d_temp$diameter <= 0 ~ buff
          , T ~ sc_temp*d_temp$diameter
        )
        , endCapStyle = "ROUND"
      ) %>% 
      sf::st_transform(crs)
    # plt
    rgb_temp <-
      ortho_plt_fn(d_temp) + 
      ggplot2::geom_sf(data = d_temp, fill = NA, color = "white", lwd = 1)
    
    # plt classifier
    class_temp <- ggplot2::ggplot() +
      ggplot2::geom_tile(
        data = cluster_rast %>%  
          terra::crop(
            d_temp %>% sf::st_buffer(20) %>% terra::vect()
          ) %>% 
          terra::as.data.frame(xy=T) %>% 
          dplyr::rename(f=3)
        , ggplot2::aes(x=x,y=y,fill=as.factor(f))
      ) +
      ggplot2::geom_sf(data = d_temp, fill = NA, color = "white", lwd = 1) +
      ggplot2::scale_fill_manual(
        values = c(
          "1" = viridis::turbo(n=6)[1]
          , "2" = viridis::turbo(n=6)[2]
          , "3" = viridis::turbo(n=6)[3]
          , "4" = viridis::turbo(n=6)[4]
          , "5" = viridis::turbo(n=6)[5]
          , "6" = viridis::turbo(n=6)[6]
          # , "7" = viridis::turbo(n=10)[7]
          # , "8" = viridis::turbo(n=10)[8]
          # , "9" = viridis::turbo(n=10)[9]
          # , "10" = viridis::turbo(n=10)[10]
        )
        , na.value = "transparent"
      ) +
      ggplot2::scale_x_continuous(expand = c(0, 0)) +
      ggplot2::scale_y_continuous(expand = c(0, 0)) +
      ggplot2::labs(
        x = ""
        , y = ""
        , fill = ""
      ) +
      ggplot2::theme_void() + 
      ggplot2::theme(
        legend.position = "left" # c(0.5,1)
        , legend.margin = margin(0,0,0,0)
        , legend.text = element_text(size = 6)
        , legend.title = element_text(size = 6)
        , legend.key = element_rect(fill = "white")
        # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
        , plot.title = element_text(size = 8, hjust = 0.5, face = "bold")
        , plot.subtitle = element_text(size = 6, hjust = 0.5, face = "italic")
      )
  plt_temp <- class_temp+rgb_temp
  return(plt_temp)
}
# add pile locations
plt_list_kmeans <- sample(1:nrow(slash_piles_sf),10) %>% 
  purrr::map(p_fn_temp)
```

combine the plots for a few piles

```{r, height = 10.5, width = 8}
patchwork::wrap_plots(
  plt_list_kmeans
  , ncol = 2
  , guides = "collect"
)
ggplot2::ggsave("../data/pile_tiles_kmeans6.jpeg", height = 10.5, width = 8)
```

there is no discernible pattern between the kmeans classes and the slash piles because the lighting and conditions around the piles are not consistent. this result also highlights the challenges we'll likely face with pixel-based classification methods


## Supervised classification

Unsupervised image classification could be used to identify slash piles by grouping pixels with similar spectral characteristics. We'll call any method that implements classification at the pixel level like the unsupervised classification approach tested here "pixel-based image analysis" versus to OBIA. Unsupervised image classification uses algorithms like K-means to find natural clusters within spectral data and can use other inputs like elevation or spectral indices. This method operates without requiring pre-defined training data, making it useful when field data is limited. The output assigns each pixel to a class, which the user then interprets to potentially identify slash piles based on their distinct spectral signatures and elevated height. While effective for initial classification and pattern recognition, unsupervised methods can produce numerous classes that require manual interpretation and may be less accurate than supervised approaches without ground truth data.

let's test it out and see what we get

first, we'll convert our rasters to a data frame