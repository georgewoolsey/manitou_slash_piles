# Point Cloud Classification

We'll use the point cloud data alone (to begin with) to attempt to classify slash piles without additional spectral information.

We'll use the `cloud2trees` package to perform all preprocessing of point cloud data which includes:

* ground classification and noise removal
* raster data (DTM and CHM) generation
* point cloud height normalization

All of this can be accomplished using the `cloud2raster()` function. After generating these products from the raw point cloud we'll perform object segmentation to attempt to detect round, conical objects like slash piles from: 1) the normalized point cloud directly; 2) the CHM which we'll generate by setting the minimum height to zero to effectively create a digital surface model (DSM).

To attempt to detect slash piles directly from the point cloud we can use a clustering algorithm such as DBSCAN (Density-Based Spatial Clustering of Applications with Noise) which identifies clusters based on point density, making it effective for detecting clusters of arbitrary shapes and sizes. It does not require the number of clusters to be specified beforehand. Insert something from TLS paper that used DBSCAN in semi-automated way....xxxxx. After segmenting the point cloud using DBSCAN, random forest can be used as a classifier (i.e. classification step) to distinguish slash piles from other objects based on their extracted geometric features. The general workflow is:

1) for each point in the normalized non-ground point cloud, compute a suite of relevant geometric features within a defined local neighborhood radius using `lidR::point_metrics()`
2) calculate features derived from PCA, such as linearity, planarity, sphericity, and surface variation. Also, compute curvature (mean, Gaussian) and roughness
3) perform object segmentation/clustering to group points belonging to individual objects using DBSCAN which can identify dense clusters without requiring a predefined number of objects
4) classify the segmented objects (clusters) as "slash pile" or "non-slash pile" based on their extracted features (e.g., sphericity, roughness, height, volume) with a random forest classifier using a manually annotated subset of segmented objects
5) merge small, adjacent segments that likely belong to a single slash pile based on proximity and connectivity
6) perform a confusion matrix-based evaluation on the results

To attempt to identify slash piles from the CHM/DSM, we can use watershed segmentation (potentially without "seed" points) in a bottom-up approach. Insert something from paper about bottom-up approach that uses a CHM "slice" near the ground...xxxxx. For slash piles, which are often irregular and may not have a distinct "treetop" equivalent, CHM-based methods might be less directly applicable unless the piles present a very clear, isolated conical or rounded form. Could use expected morphology of the slash piles (e.g. maximum height) based on prior research.

## Process Raw Point Cloud

We'll use `cloud2trees::cloud2raster()` to process the raw point cloud data

```{r, include=FALSE,eval=FALSE}
# something bad is happening with this point cloud
errors_temp <- sf::st_read("D:\\PFDP_Data\\las_errors/error_areas.shp") %>% 
  dplyr::rename_with(tolower)
mapview::mapview(errors_temp)
las_temp <- lidR::clip_roi(
  las_ctg
  , errors_temp %>% 
    dplyr::slice(2) %>% 
    sf::st_transform(lidR::st_crs(las_ctg))
)
lidR::decimate_points(las_temp, algorithm = lidR::random(10)) %>% lidR::plot()

lidR::writeLAS(las_temp, "D:\\PFDP_Data\\las_errors/las_error2.las", index = T)

xxx_temp <- cloud2trees::cloud2raster(
  output_dir = tempdir()
  , input_las_dir = "D:\\PFDP_Data\\las_errors/las_error2.las"
  , dtm_res_m = 0.5
  , chm_res_m = 0.2
)
xxx_temp$dtm_rast %>% 
  # terra::aggregate(2,na.rm = T) %>% 
  terra::plot()
xxx_temp$chm_rast %>% 
  # terra::aggregate(2,na.rm = T) %>% 
  terra::plot()

### this is from cloud2raster for combining dtm tiles
###############
# DTM
###############
  # output name
  dtm_file_name <- paste0("../data/error_point_cloud_processing_delivery", "/dtm_", 0.1, "m.tif")
  # read
  rast_list_temp <- list.files("../data/error_point_cloud_processing_temp/03_dtm", pattern = ".*\\.(tif|tiff)$", full.names = T) %>%
    purrr::map(function(x){terra::rast(x)})
  rast_list_temp[[12]] %>% 
    # terra::aggregate(2,na.rm = T) %>% 
    terra::plot()
  # mosaic
  dtm_rast <- terra::sprc(rast_list_temp) %>% terra::mosaic(fun = "mean")
  dtm_rast %>% 
    terra::aggregate(2,na.rm = T) %>% 
    terra::res() %>% 
    terra::plot()
  # set crs
    terra::crs(dtm_rast) <- chunk_las_catalog_ans$process_data$proj_crs[1]
  # write to delivery directory
    terra::writeRaster(
      dtm_rast
      , filename = dtm_file_name
      , overwrite = T
    )
##########################################
    # lidR point segmentation
las <- lidR::segment_shapes(
  las
  , algorithm = lidR::shp_hplane(k = 25)
  , attribute = "planar"
)
# Realtime_detection_of_planar_regions_in_unorganized_point_clouds
lidR::point_eigenvalues()
```


```{r}
if(!dir.exists("../data/point_cloud_processing_delivery")){
  cloud2raster_ans <- cloud2trees::cloud2raster(
    output_dir = "../data"
    , input_las_dir = "D:\\PFDP_Data\\p4pro_images\\P4Pro_06_17_2021_half_half_optimal\\2_densification\\point_cloud"
    , max_ctg_pts = 9e+07
    , accuracy_level = 3
    , keep_intrmdt = T
    , dtm_res_m = 0.5
    , chm_res_m = 0.2
    , min_height = 0 # effectively generates a DSM based on non-ground points
  )
}else{
  dtm_temp <- terra::rast("../data/point_cloud_processing_delivery/dtm_0.5m.tif")
  chm_temp <- terra::rast("../data/point_cloud_processing_delivery/chm_0.2m.tif")
  cloud2raster_ans <- list(
    "dtm_rast" = dtm_temp
    , "chm_rast" = chm_temp
  )
}
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

let's check out the DTM

```{r}
cloud2raster_ans$chm_rast %>% 
  # terra::clamp(lower = 2) %>% 
  # terra::summary()
  terra::aggregate(fact = 2) %>%  #, fun = "median", cores = lasR::half_cores(), na.rm = T) %>% 
  terra::plot(col = viridis::viridis(100), add = T)

```

and CHM